{"version":3,"file":"static/js/283.4d311dd3.chunk.js","mappings":"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","sources":["../node_modules/dag-jose/node_modules/multiformats/vendor/base-x.js","../node_modules/dag-jose/node_modules/multiformats/src/bytes.js","../node_modules/dag-jose/node_modules/multiformats/src/bases/base.js","../node_modules/dag-jose/node_modules/multiformats/src/bases/base64.js","../../src/utils.ts","../node_modules/dag-jose/node_modules/multiformats/vendor/varint.js","../node_modules/dag-jose/node_modules/multiformats/src/varint.js","../node_modules/dag-jose/node_modules/multiformats/src/hashes/digest.js","../node_modules/dag-jose/node_modules/multiformats/src/bases/base58.js","../node_modules/dag-jose/node_modules/multiformats/src/bases/base32.js","../node_modules/dag-jose/node_modules/multiformats/src/cid.js","../../src/signing.ts","../../src/encryption.ts","../../src/index.ts"],"sourcesContent":["// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n","const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n","import basex from '../../vendor/base-x.js'\nimport { coerce } from '../bytes.js'\n// Linter can't see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.BaseEncoder}\n */\nclass Encoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   */\n  constructor (name, prefix, baseEncode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {API.Multibase<Prefix>}\n   */\n  encode (bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * @template {string} Prefix\n */\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.UnibaseDecoder<Prefix>}\n * @implements {API.BaseDecoder}\n */\nclass Decoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    /* c8 ignore next 3 */\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    /** @private */\n    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))\n    this.baseDecode = baseDecode\n  }\n\n  /**\n   * @param {string} text\n   */\n  decode (text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n}\n\n/**\n * @template {string} Prefix\n * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders\n */\n\n/**\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.CombobaseDecoder<Prefix>}\n */\nclass ComposedDecoder {\n  /**\n   * @param {Decoders<Prefix>} decoders\n   */\n  constructor (decoders) {\n    this.decoders = decoders\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n\n  /**\n   * @param {string} input\n   * @returns {Uint8Array}\n   */\n  decode (input) {\n    const prefix = /** @type {Prefix} */ (input[0])\n    const decoder = this.decoders[prefix]\n    if (decoder) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\n/**\n * @template {string} L\n * @template {string} R\n * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left\n * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right\n * @returns {ComposedDecoder<L|R>}\n */\nexport const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({\n  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),\n  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })\n}))\n\n/**\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseCodec<Prefix>}\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.BaseCodec}\n * @implements {API.BaseEncoder}\n * @implements {API.BaseDecoder}\n */\nexport class Codec {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseEncode, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  encode (input) {\n    return this.encoder.encode(input)\n  }\n\n  /**\n   * @param {string} input\n   */\n  decode (input) {\n    return this.decoder.decode(input)\n  }\n}\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {(bytes:Uint8Array) => string} options.encode\n * @param {(input:string) => Uint8Array} options.decode\n * @returns {Codec<Base, Prefix>}\n */\nexport const from = ({ name, prefix, encode, decode }) =>\n  new Codec(name, prefix, encode, decode)\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @returns {Codec<Base, Prefix>}\n */\nexport const baseX = ({ prefix, name, alphabet }) => {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    /**\n     * @param {string} text\n     */\n    decode: text => coerce(decode(text))\n  })\n}\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @param {string} name\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n *\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @param {number} options.bitsPerChar\n */\nexport const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {\n  return from({\n    prefix,\n    name,\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n","// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n",null,"var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n","import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n","import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import * as varint from './varint.js'\nimport * as Digest from './hashes/digest.js'\nimport { base58btc } from './bases/base58.js'\nimport { base32 } from './bases/base32.js'\nimport { coerce } from './bytes.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   *\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n"],"names":["ALPHABET","name","length","TypeError","BASE_MAP","Uint8Array","j","i","x","charAt","xc","charCodeAt","BASE","LEADER","FACTOR","Math","log","iFACTOR","decodeUnsafe","source","psz","zeroes","size","b256","carry","it3","Error","it4","vch","encode","ArrayBuffer","isView","buffer","byteOffset","byteLength","Array","isArray","from","pbegin","pend","b58","it1","it2","str","repeat","decode","string","coerce","o","constructor","Encoder","prefix","baseEncode","this","bytes","Decoder","baseDecode","undefined","codePointAt","prefixCodePoint","text","JSON","stringify","slice","or","decoder","ComposedDecoder","decoders","input","RangeError","Object","keys","left","right","Codec","encoder","baseX","alphabet","rfc4648","bitsPerChar","data","pad","mask","out","bits","codes","end","written","value","SyntaxError","base64url","encode_1","num","offset","oldOffset","INT","MSB","MSBALL","pow","read","buf","b","res","shift","counter","l","REST$1","MSB$1","N1","N2","N3","N4","N5","N6","N7","N8","N9","encodingLength","encodeTo","int","target","Digest","code","digest","base58btc","base32","format","link","base","version","toStringV0","baseCache","toStringV1","cache","WeakMap","cid","get","Map","set","CID","multihash","asCID","toV0","DAG_PB_CODE","SHA_256_CODE","createV0","toV1","sizeOffset","digestOffset","createV1","equals","other","self","unknown","a","aa","bb","ii","toString","toJSON","Symbol","toStringTag","for","encodeCID","cidSymbol","subarray","create","remainder","decodeFirst","specs","inspectBytes","prefixSize","multihashSize","multihashBytes","digestBytes","digestSize","multihashCode","codec","initialBytes","next","parse","parseCIDtoBytes","codeOffset","hashOffset"],"sourceRoot":""}